%klrfclass 'Classify Image Using the Localized Receptive Field Classifier (K1)'
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros lrfclass.pane file
%
% Parameters: 
% InputFile: i1 'Input image', required: 'input image'
% InputFile: i2 'Cluster Center image ', required: 'cluster center image'
% InputFile: i3 'Cluster Variance image', required: 'cluster variance image'
% InputFile: i4 'Weight image', required: 'weight image'
% Integer: b 'Input Image Border Width', default: 0: 'Border Width'
% OutputFile: o 'Classified image', required: 'classified image'
%
% Example: o = klrfclass({i1, i2, i3, i4}, {'i1','';'i2','';'i3','';'i4','';'b',0;'o',''})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% lrfclass - Classify Image Using the Localized Receptive Field Classifier  (K1)
%
%  DESCRIPTION
% .I lrfclass
% classifies an image using the Localized Receptive Field classifier (LRF).
% The Localized Receptive Field (LRF) is based on a single layer of 
% self-organizing, "localized receptive field" units, followed by a
% single layer perceptron.  The single layer of perceptron units use the 
% LMS or Adaline learning rule to adjust the weights.  The weights are
% adjusted or "trained" using the companion program, "lrftrain".  After
% training the weights, using the "lrftrain" program, a number of similar
% images may be quickly classified with this program based on the training
% data set.
% .SH "LRF network theory"
% 
% The basic network model of the LRF consists of a two layer topology.
% The first layer of "receptive field" nodes are trained using a clustering
% algorithm, such as K-means, or some other algorithm which can determine
% the receptive field centers.  Each node in the first layer computes a
% receptive field response function, which should approach zero as the
% distance from the center of the receptive field is increased.  The second
% layer of the LRF model sums the weighted outputs of the first layer,
% which produces the output or response of the network.  A supervised
% LMS rule is used to train the weights of the second layer nodes.
% 
% The response function of the LRF network is formulated as follows:
% .DS
% 
%              f(x) = SUM(Ti * Ri(x))
% 
% where,
% 
%       Ri(x) = Q( ||x - xi|| / Wi )
% 
%       x  -  is a real valued vector in the input space,
%       Ri -  is the ith receptive field response function,
%       Q  -  is a radially symmetric function with a single
%             maximum at the origin, decreasing to zero at
%             large radii,
%       xi -  is the center of the ith receptive field,
%       Wi -  is the width of the ith receptive field,
%       Ti -  is the weight associated with each receptive field.
% 
% .DE
% 
% The receptive field response functions ( Ri(x) ), should be formulated
% such that they decrease rapidly with increasing radii.  This ensures that
% the response functions provide highly localized representations of the
% input space.  The response function used in this algorithm is modeled after 
% the Gaussian, and uses the trace of the covariance matrix to set the widths
% of the receptive field centers.
% 
% Prior to using this algorithm, it is necessary to "train" the weights for
% the output layer by running the companion program, "lrftrain", on a previously
% clustered image.  Thus the inputs to this program are the original input
% image (-i1), the cluster center image (-i2), the cluster variance image (-i3),
% and the weight image (-i4).  The original input image contains all of the 
% features used in the original clustering (ie. vkmeans).  The cluster center
% image (-i2) contains the locations of the cluster centers in the input
% feature space, which fixes the centers of the localized receptive fields. 
% The cluster variance image (-i3) contains the variances associated with
% each cluster center.  This establishes the widths of the localized receptive
% field Gaussians.  The weight image (-i4) contains all of the weights for
% each node in the output layer.
% 
% The number of receptive field response nodes in the first layer of the
% LRF is determined by the number of cluster centers in the "cluster center"
% image.  The number of output classes, and hence the number of output
% nodes in the second (ie. last) layer, is determined by the number of
% desired classes that was specified in the "supervised" classification
% phase of the clustering.  This information is contained in the last
% band of the cluster center image.  The number of weights in the network
% is determined by the number of receptive field response nodes and the
% number of output nodes.  That is,
% .DS
% 
%   #Wts = (#rf_response_nodes * #output_nodes) + #output_nodes
% 
% .DE
% 
% The resulting output image is classified with the desired number of
% classes specified in the last band of the "cluster center" (-i2) image.
% The number of desired classes corresponds to the number of output nodes
% in the last layer of the LRF network.  This classified image is of
% data storage type INTEGER.
% .SH "Input Options"
% 
% 
%  "-b" 8
% is an integer that specifies the border width, in pixels, encompassing
% the desired region of the image to be classified.  This region is ignored
% during the classification process.
% 
% This routine was written with the help of and ideas from
% Dr. Don Hush, University of New Mexico, Dept. of EECE.
%
%  
%
%  EXAMPLES
% lrfclass -i1 feature_image.xv -i2 cluster_centers -i3 variances -i4 weight_image -o classified_image -b 4
% 
% This example uses feature_image.xv as the input feature image, and the
% three other images from the companion program "lrftrain". These include
% the cluster_centers image, the variances image, and the weight_image.  
% The resulting classified image is stored as "classified_image".  A border 
% width of 4 pixels is specified, which will cause the outermost four pixels 
% of the image to be ignored.
%
%  "SEE ALSO"
% lrftrain(1)
%
%  RESTRICTIONS 
% All input images MUST be of data storage type FLOAT.  The resulting
% classified image (-o) is of data storage type INTEGER.
%
%  REFERENCES 
%
%  COPYRIGHT
% Copyright (C) 1993 - 1997, Khoral Research, Inc. ("KRI")  All rights reserved.
% 


function varargout = klrfclass(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = klrfclass(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'i1', '__input';'i2', '__input';'i3', '__input';'i4', '__input';'b', 0;'o', '__output'};
maxval={0,0,0,0,100,0};
minval={0,0,0,0,0,0};
istoggle=[0,0,0,0,1,0];
was_set=istoggle * 0;
paramtype={'InputFile','InputFile','InputFile','InputFile','Integer','OutputFile'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=1; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'lrfclass"  '],Inputs,narglist);
