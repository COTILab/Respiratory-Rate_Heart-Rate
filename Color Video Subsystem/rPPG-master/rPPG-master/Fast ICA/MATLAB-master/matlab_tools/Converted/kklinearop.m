%kklinearop 'Performs linear operations (convolution/correlation)'
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros klinearop.pane file
%
% Parameters: 
% InputFile: i1 'Input Object ', required: 'Input object '
% InputFile: i2 'Input Kernel ', required: 'Input kernel'
% Toggle: upcast 'Upcast data', default: 0: 'Upcast data to double or double complex for processing'
% Integer: wc 'Width ', default: 0: 'Width coordinate of kernel hotspot'
% Integer: hc 'Height ', default: 0: 'Height coordinate of kernel hotspot'
% Integer: dc 'Depth ', default: 0: 'Depth coordinate of kernel hotspot'
% Integer: tc 'Time ', default: 0: 'Time coordinate of kernel hotspot'
% Integer: ec 'Elements', default: 0: 'Element coordinate of kernel hotspot'
% Integer: woff 'Width ', default: 0: 'Width offset for subregion'
% Integer: hsize 'Height ', default: 1: 'Height size for subregion'
% Integer: hoff 'Height ', default: 0: 'Height offset for subregion'
% Integer: wsize 'Width ', default: 1: 'Width size for subregion'
% Integer: doff 'Depth ', default: 0: 'Depth offset for subregion'
% Integer: dsize 'Depth ', default: 1: 'Depth size for subregion'
% Integer: toff 'Time ', default: 0: 'Time offset for subregion'
% Integer: tsize 'Time ', default: 1: 'Time size for subregion'
% Integer: eoff 'Elements', default: 0: 'Elements offset for subregion'
% Integer: esize 'Elements', default: 1: 'Elements size for subregion'
% OutputFile: o 'Output Object ', required: 'output object'
% Toggle: l 'Linear', default: 0: 'If flag is set, handle boundaries by padding'
% Toggle: c 'Circular', default: 0: 'If flag is set, handle boundaries by wrapping'
%
% Example: o = kklinearop({i1, i2}, {'i1','';'i2','';'upcast',0;'wc',0;'hc',0;'dc',0;'tc',0;'ec',0;'woff',0;'hsize',1;'hoff',0;'wsize',1;'doff',0;'dsize',1;'toff',0;'tsize',1;'eoff',0;'esize',1;'o','';'l',0;'c',0})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% klinearop - Performs linear operations (convolution/correlation)
%
%  DESCRIPTION
% "klinearop" performs convolution and correlation operations
% on a data object, using a specified kernel. These are both linear operations,
% thus the name "klinearop".
% 
% In both cases, the operation can be essentially be viewed as moving a 
% weighting mask (the kernel) over
% the data, performing a multiply-accumulate operation between the mask and the
% data under the mask, and storing the result in the output data. The weighting 
% mask can
% have a specific location defined as the "center" or "hotspot"; when
% moving the mask around, this location will be placed directly on top of each
% data point in the input data, with the result stored in the corresponding
% location of the output data.
% 
% It is possible that when the kernel hotspot is positioned at certain 
% locations (around the boundary of the input
% data) the kernel may partially extend outside the actual data. To handle this
% situation, it is common to pad the data with a specified value (often zero)
% so that those kernel weights that lie outside the actual data are multiplied
% by the pad value. The other alternative is to enforce circular (periodic)
% boundaries on the data (this is what an FFT does implicitly). Both boundary 
% handling techniques are available in "klinearop".
% 
% The difference between correlation and convolution is that correlation uses
% the kernel in exactly the orientation that it is handed to "klinearop",
% while convolution uses a version of the kernel that is reversed or flipped
% along each of it's axes.
% 
% "klinearop" also has the ability to operate only on a specified
% region (called a subregion) of the input object. Data points in the output
% object that correspond to those in the specified subregion of the input object
% will be replaced with the value obtained by the linear operation. All other
% output data points will be copied directly from the corresponding input
% data points. Note that the boundary handling procedures will only affect data
% that lies near the edge of the input data array, "not" the edge of
% the subregion, unless the subregion includes areas near the edge of the
% input data.
% 
% The dimensionality of the linear operation is controlled by the dimensions
% of the kernel. For example, using a 5x1x1x1x1 kernel on a 512x512x1x20x1 input
% data object will cause a 1D operation to be done independently on each of the
% (512*20) rows in the input data. The size of the kernel must make sense;
% it is not likely that a kernel that is larger than the data in some direction
% will produce the correct result.
% 
% The multiply-accumulate operation is done in the higher of the kernel and data
% data types, unless the -upcast argument is given. In this
% case the data is cast to either DOUBLE or DCOMPLEX before processing, and
% the result will also be of that type. If the -upcast argument is not used,
% the result will be of the same data type as the input data.
% 
% Input objects with a map attached are mapped before processing; the output
% will have no map.
% 
% If either the input object or the kernel has mask data, then an error is
% returned since klinearop doesn't know how to handle those cases at this time.
% 
% A kernel, as referred to in this man page, is a small data object
% that has a sampled spatial impulse response (of the linear system you are 
% modeling) stored in the value segment. Any data object of this type can be
% used as kernel. For images, it is common to create a kernel by typing the
% kernel values into an ASCII file as a 2D array in width and height and 
% using that file directly as the kernel (thanks to data services). Kernels
% can also be created using xprism or any of the data generation programs.
% They can also be extracted directly from an existing image.
% There are several commonly used kernels in the SAMPLEDATA toolbox in
% $SAMPLEDATA/data/kernels.
% 
% Large data set handling is not explicitly done in klinearop. The data is 
% processed by regions where the size of a region is controlled by the
% kernel and data region dimensions: The processing region dimensions are of
% size 1 for each direction that the kernel is of size 1, and the size if the
% data region for all other directions. Thus for the previous example of using
% a 5x1x1x1x1 kernel on a 512x512x1x20x1 input data object, with the whole data
% object selected for convolution (or correlation), the data will be processed
% in 512x1x1x1x1 chunks. If the kernel were 5x1x1x5x1, then the data would
% be processed in chunks of 512x1x1x20x1. Processing of large data sets is
% thus limited to the maximum "chunk size" that can reasonable be kept
% in memory. For example, using a 7x7x7x7x1 kernel on a 512x512x16x256x3
% data object would require a processing region of size (512*512*16*256)
% double floats, around 8192MB. It is clear that you would want to
% do something with the kernel here; possibly break it down into separable
% parts that can be convolved independently. Removing this restriction
% on large data set handling is a topic for future work.
%
%  
%
%  EXAMPLES
% Convolution between input_image, and kernel_image, with offset (0,0), pad 
% value 0 for the real part and 0 for the imaginary part is:
% klinearop -i1 input_image -i2 kernel_image -o output_image -corr 0 -l -real 0 -imag 0
%
%  "SEE ALSO"
% kfft(1)
%
%  RESTRICTIONS 
% 
% Large data set handling can be strange; see the above discussion.
%
%  REFERENCES 
% 1) FUNDAMENTALS OF IMAGE PROCESSING by A. K. Jain, Prentice Hall, 1989.
% 2) DIGITAL IMAGE PROCESSING by Rafael C. Gonzalez and Richard E. Woods,
% Addison Wesley, 1992.
% 3) DIGITAL IMAGE PROCESSING, 2nd. Ed., by William K. Pratt, Wiley, 1991.
% 4) MULTIDIMENSIONAL DIGITAL SIGNAL PROCESSING, by Dan E. Dudgeon and 
% Russell M. Mersereau, Prentice Hall, 1984.
% 5) DISCRETE-TIME SIGNAL PROCESSING, by Alan V. Oppenheim and Ronald W.
% Schafer, Prentice Hall, 1989.
% 6) TWO-DIMENSIONAL SIGNAL AND IMAGE PROCESSING, by Jae S. Lim, Prentice Hall,
% 1990.
%
%  COPYRIGHT
% Copyright (C) 1993 - 1997, Khoral Research, Inc. ("KRI")  All rights reserved.
% 


function varargout = kklinearop(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kklinearop(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'i1', '__input';'i2', '__input';'upcast', 0;'wc', 0;'hc', 0;'dc', 0;'tc', 0;'ec', 0;'woff', 0;'hsize', 1;'hoff', 0;'wsize', 1;'doff', 0;'dsize', 1;'toff', 0;'tsize', 1;'eoff', 0;'esize', 1;'o', '__output';'l', 0;'c', 0};
maxval={0,0,0,1,1,1,1,1,0,2,0,2,0,2,0,2,0,2,0,0,0};
minval={0,0,0,1,1,1,1,1,0,2,0,2,0,2,0,2,0,2,0,0,0};
istoggle=[0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1];
was_set=istoggle * 0;
paramtype={'InputFile','InputFile','Toggle','Integer','Integer','Integer','Integer','Integer','Integer','Integer','Integer','Integer','Integer','Integer','Integer','Integer','Integer','Integer','OutputFile','Toggle','Toggle'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=1; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'klinearop"  '],Inputs,narglist);
