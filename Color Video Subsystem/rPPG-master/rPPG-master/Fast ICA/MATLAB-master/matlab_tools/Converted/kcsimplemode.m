%kcsimplemode 'Apply a mode operator over classification results'
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros csimplemode.pane file
%
% Parameters: 
% InputFile: i 'Input Classification Result', required: 'input classification result image'
% Integer: width 'Mask Width', default: 3: 'mask width integer'
% Integer: height 'Mask Height', default: 3: 'mask height integer'
% Integer: repetitions 'Repetitions', default: 1: 'how many times the filtering will be done'
% OutputFile: o 'Output', required: 'Resulting output filtered classified image'
%
% Example: o = kcsimplemode(i, {'i','';'width',3;'height',3;'repetitions',1;'o',''})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% csimplemode - Apply a mode operator over classification results
%
%  DESCRIPTION
% This program calculates a mode filter over regions on the input image (specified with the [-i] parameter). The mode filter is a filter which extract from a region the most present value on the region. For image processing tasks, it is used to remove spikes while preserving edges, but to be effective it must be applied on an image with a small number of distinct gray levels or colors. Since a classified image usually have only few different values (usually indexes for classes), it can be used to smooth classified regions - removing small areas of class X inside large areas of class Y, for example. In this sense, the filter enhances the homogeneity of the classified regions.
% The filter basic parameters are [-width] and [-height] which specifies the dimensions (will be roughly correspondent to 2 times the size of the regions that will be merged) and [-repetitions] which specifies how many times the filter will be applied.
% This implementation is a special version of the most common mode filter (as the one present in the ImagePlus toolbox, for example). It considers the mask in the input object - which represents rejected pixels in the classification or pixels that were masked before classification. There are two actions that can be taken if there are masked pixels in the region:
% * If the parameter [-propagatemask] is set to TRUE and the masked pixels in the region are the majority of the pixels, mask will be propagated: the pixel central to the region will be masked too.
% * If the parameter [-propagatemask] is set to FALSE and the masked pixels in the region are the majority of the pixels, mask will \fBnot" be propagated: the value for the pixel central to the region will be determined by using the mode of the non-masked pixels in the input.
% Pixels in the border will also be filtered, but using smaller regions than the specified. 
% Usually classification results will have only one element dimension, but this routine is able to process multielement images just in case.
% Map information is just copied from the input to the output, meaning that it doesn't matter if the filter is applied before or after a thematic map creation.
%
%  
%
%  EXAMPLES
% All examples for the Classify toolbox are listed on the Classify Toolbox Manual. For an example of this operator, please see the Classify:workspaces:KNN sample workspace.
%
%  "SEE ALSO"
%
%  RESTRICTIONS 
% The mode filter is more effective when there are few possible values on the region, like in a classification result image. If applied to image with more values the results won't be that good.
%
%  REFERENCES 
% All references for the Classify toolbox are listed on the Classify Toolbox Manual.
%
%  COPYRIGHT
% Copyright (C) 1997 Rafael Santos. Khoros (C) Khoral Research, Inc.
% 


function varargout = kcsimplemode(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kcsimplemode(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'i', '__input';'width', 3;'height', 3;'repetitions', 1;'o', '__output'};
maxval={0,2,2,2,0};
minval={0,2,2,2,0};
istoggle=[0,0,0,1,0];
was_set=istoggle * 0;
paramtype={'InputFile','Integer','Integer','Integer','OutputFile'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=1; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'csimplemode"  '],Inputs,narglist);
