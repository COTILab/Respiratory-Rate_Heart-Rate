%kcmaxlik_classify 'Classify an object using the Maximum Likelihood algorithm'
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros cmaxlik_classify.pane file
%
% Parameters: 
% InputFile: iimage 'Input Image', required: 'input image file'
% InputFile: isigs 'Input Signatures file', required: 'input signatures file'
% InputFile: iapp 'Input A-Priori Prob.', optional: 'input a-priori probabilities file'
% Integer: likelihoodrank 'Use likelihood rank', default: 1: 'likelihood rank integer'
% Toggle: mahalanobis 'Calculate Mahalanobis distance instead of of Maximum Likelihood', default: 0: 'if set will use the Mahalanobis distance instead of maxlik'
% OutputFile: oclass 'Output Classified', required: 'output classified image'
% OutputFile: oprob 'Output Likelihoods', optional: 'output a-posteriori probabilities'
% OutputFile: oinfo 'Output Information', optional: 'output information about classification'
%
% Example: [oclass, oprob, oinfo] = kcmaxlik_classify({iimage, isigs, iapp}, {'iimage','';'isigs','';'iapp','';'likelihoodrank',1;'mahalanobis',0;'oclass','';'oprob','';'oinfo',''})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% cmaxlik_classify - Classify an object using the Maximum Likelihood algorithm
%
%  DESCRIPTION
% This routine classifies an input object using the Maximum Likelihood classification algorithm (or alternatively the Minimum Mahalanobis Distance algorithm). The Maximum Likelihood algorithm is a powerful classification algorithm that assigns a class C to a pixel X if the distance of a prototype of C to the vector X is the smallest between all known classes. The distance is measured considering the covariances of the classes, so this classifier will be able to classify pixels distributes in hyperellipsoids. More details about the Maximum Likelihood classifier are on the Classify Toolbox Manual.
% If the parameter [-mahalanobis] is used, the distance will be measured by the Mahalanobis distance, else it will be measured by normal Maximum Likelihood algorithm (which uses the negative log of the determinate of the covariance matrix). Points which are too far from the mean vector can be rejected if the [-reject] parameter is passed with a percentage of points to reject (chi-square based rejection).
% This routine requires an object to be classified (passed with the [-iimage] parameter) and a set of classes's signatures object created by "cmaxlik_signature" and appended by \fIkappend\fP (passed with the [-isigs] parameter). Optionally an a-priori probability file with a-priori data for each class can be passed with the [-iapp] parameter. 
% This routine will create the output classification result in the file specified by [-oclass]. Optionally the final probabilities for each point and each class can be created if the parameter [-oprob] is used. If a file is specified in the parameter [-oinfo] the classification results will be written to that file in ASCII (can get large for large images).
% The expected dimensions of the input and output objects are shown below:
% The input object which will be classified ([-iimage]) will have dimensions WxHxDxTxF, where F is the number of features. If it has mask, the masked points won't be classified, and the corresponding points in the output will have value 0 and mask 0.
% The input signatures must have dimensions FxFx5xNx1, where N is the number of classes. It must be created by using "cmaxlik_signature" and \fIkappend\fP. 
% If the parameter [-iapp] is used, its file must be in ASCII format, with lines starting by # or / considered as comments, one a-priori information per line (where each line corresponds to a class), and each non-commented line with two values separated by spaces, the first one being the class index and the second one being the a-priori information for that class.
% The output object [-oclass] will have dimensions WxHxDxTx1, and its value segment will have values on the range 0..N, where 0 means that the pixel was rejected. It will also have a corresponding mask segment with values 0 for the rejected pixels and 1 for the non-rejected pixels. The values for the pixels will be associated accordingly to the order the signatures were appended with "kappend".
% If the parameter [-oprob] is used, it will have dimensions WxHxDxTxN.
% Alternatively to the Maximum Likelihood classification, the second (or third, or N-th) likelihood result can be obtained by specifying an index in the [-likelihoodrank] parameter.
% Please refer to the Classify toolbox manual or for one of the example workspaces for usage examples and details.
%
%  
%
%  EXAMPLES
% All examples for the Classify toolbox are listed on the Classify Toolbox Manual. For examples of this program, please see the Classify:workspaces:MAXLIK and Classify:workspaces:MAXLIK-Classify example workspaces.
%
%  "SEE ALSO"
% cmaxlik_signature, kappend
%
%  RESTRICTIONS 
% Expects the signatures to be valid signatures for the Maximum Likelihood algorithm.
%
%  REFERENCES 
% All references for the Classify toolbox are listed on the Classify Toolbox Manual.
%
%  COPYRIGHT
% Copyright (C) 1997 Rafael Santos. Khoros (C) Khoral Research, Inc.
% 


function varargout = kcmaxlik_classify(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kcmaxlik_classify(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'iimage', '__input';'isigs', '__input';'iapp', '__input';'likelihoodrank', 1;'mahalanobis', 0;'oclass', '__output';'oprob', '__output';'oinfo', '__output'};
maxval={0,0,1,2,0,0,1,1};
minval={0,0,1,2,0,0,1,1};
istoggle=[0,0,1,1,1,0,1,1];
was_set=istoggle * 0;
paramtype={'InputFile','InputFile','InputFile','Integer','Toggle','OutputFile','OutputFile','OutputFile'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=1; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'cmaxlik_classify"  '],Inputs,narglist);
