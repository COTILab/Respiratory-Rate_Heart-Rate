%kkgenstruct 'Generates code used by the structure read and write code'
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros kgenstruct.pane file
%
% Parameters: 
% InputFile: x 'Input Specification', required: 'structure specification'
% String: tb 'Toolbox', default: ' ': 'Toolbox to run kgenstruct on'
% String: oname 'Object', default: ' ': 'Object name to run kgenstruct on'
%
% Example: kkgenstruct(x, {'x','';'tb',' ';'oname',' '})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% kgenstruct - Generates code used by the structure read and write code
%
%  DESCRIPTION
% Kgenstruct is a program which parses a specification file defining a 
% structure and generates C code for translating an instance of that 
% structure between memory and a file.  This is handled by two generated 
% calls, one which writes an instance of the structure in memory out to a 
% file, and one which reads the structure back into memory from a file. 
% Additional calls are generated for comparing two structures and for
% freeing a structure.  
% 
% 
% These calls calls can be encapsulated as methods for handling the structure
% as a "data type" in the Khoros system via a generated define call.  
% Once defined, a type identifier for the structure will be initialized.   
% This type identifier, analagous to the Khoros type identifiers for \fBKINT", 
% \fBKFLOAT", or other data type, is used to identify a variable's data type 
% to various Khoros programs.  In particular, once defined, variables of
% the new structure type can be read and written using the \fBkwrite_generic"
% and \fBkread_generic" calls.  These calls provide the machine conversion
% capability necessary to write data in the native format for one architecture
% and convert the data while it is being read into the native format for
% a different architecture. 
% 
% 
% The read and write calls are themselves generated using the Khoros transport 
% calls.  Component pieces of the structure are read and written using the 
% \fBkread_generic" and \fBkwrite_generic\fP calls.  These calls will
% read and write a structure in pieces, breaking it down field by field. 
% 
% 
% Pointers are traversed on reading and writing using the \fBkwrite_pointer" 
% and \fBkread_pointer" calls. The write call manages the addresses of 
% what is being pointed at, ensuring that items being pointed at are
% not written more than once.  The read call then manages the addresses
% of what is being read, reconnecting pointers to restore the structure
% as it existed before being written.  This capability allows for the storage
% and retrieval of very complicated structures with cyclic and redundant
% pointer dependencies.
% 
% 
% The specification files, by convention, end with a \fB.x" extension.
% The specifications are syntactically nearly identical to C, with 
% multiple structures allowed per file. The specification files are 
% preprocessed through cpp, so cpp directives such as \fB#include", 
% \fB#ifdef", and \fB#define\fP can be used in the specification file.
% 
% 
% Two files are generated from the specification, a header file and a 
% C code file.  The naming convention for these files is to prepend \fBio_"
% to the name of the specification file.  Thus, for a specification
% foobar.x, the files io_foobar.c and io_foobar.h will be generated.
% 
% 
% The program takes a \fBtoolbox" and \fBobject name\fP argument.  If these 
% are not provided, then the toolbox and object names will be extracted from
% the local Imakefile.
% If the specification file is part of a library object, the generated
% C code file will be generated in that library's source directory , and the
% generated header file will be added to the library's public include
% directory.  If the specification file is part of any other type of
% software object, the generated C code and header files will be generated
% in the software object's source directory.  Note that kgenstruct can be 
% used on .x files outside of the context of the Khoros system, in which
% case the generated C code and header is generated in the local directory.
% 
% 
% This program is a ported and heavily modified version of rpcgen.  As such,
% it is capable of parsing nearly all of RPCL, a protocol description language 
% which is an extension of the XDR definition language.  In addition to 
% allowing structure specifications, typdefs, enumarations, and constants can 
% also be specified.   There can be multiple specifications within a single
% specification file.   C-style comments within the specification are ignored.
% Lines beginning with "!" are passed through to the header file, without the "!".
% 
% 
% Within a structure, there are four types of declarations allowed : 
% simple, fixed arrays, variable arrays, and pointers.  These are all
% identical to C, with the exception of variable arrays.  Variable arrays
% are specified using a "<>" construct.  From this, a structure in the
% header containing a length and variable array pointer is generated.
% 
% 
% The following example illustrates a structure specification using several
% different declarations :
% 
% .begin code
% struct foobar {
%    char   id;
%    int    a;      /* simple */
%    float  b[10];  /* fixed array */
%    float  c<>;    /* variable array */
%    float *d;      /* pointer */
%    kstring name;    /* use kstring for strings */ 
%    struct foobar *next;  /* these can be structures too */
% }
% .end code
% 
% The following is generated from that specification in the header file :
% 
% .begin code
% struct foobar {
%    char id;
%    int a;
%    float b[10];
%    struct {
%       unsigned int c_len;
%       float *c_val;
%    } c;
%    float *d;
%    kstring name;
%    struct foobar *next;
% };
% 
% extern int KTYPE_FOOBAR;
% 
% int  kdefine_foobar PROTO((void));
% 
% .end code
% 
% As this illustrates, with the exception of variable length arrays, the
% generated header will be identical to the specification. 
% The structure type identifier that is created is "KTYPE_FOOBAR", the 
% corresponding \fBkdefine_foobar()" call is used to initialize that
% type identifier.
% 
% 
% Note that it is important that the defined structure being written
% is identical to the defined structure being read, otherwise the structure
% reading will not succeed.  To assist in managing various versions of a 
% structure, the ability to specify a version number for a structure has 
% been added.  The version number should be specified in the .x file,
% immediately after the identifier.  The following example illustrates this :
% 
% .begin code
% struct point version 2.0 {
%    float x;
%    float y;
%    float z;
% };
% .end code
% 
% The version is optional. If not specified, the structure will not be 
% versioned.  Note that structures stored with a particular version number
% will only be readable by code defined with the identical version number.  
% Unversioned structures will not match stored versioned structures.
%
%  
%
%  EXAMPLES
%
%  "SEE ALSO"
%
%  RESTRICTIONS 
% The RPCL union construct is not supported.  Similarly, there is no
% notion of opaque or bool in kgenstruct.
%
%  REFERENCES 
% "Power Programming with RPC", John Bloomer, O'Reilly & Associates, 1992.
%
%  COPYRIGHT
% Copyright (C) 1993 - 1997, Khoral Research, Inc. ("KRI")  All rights reserved.
% 


function varargout = kkgenstruct(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kkgenstruct(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'x', '__input';'tb', ' ';'oname', ' '};
maxval={0,0,0};
minval={0,0,0};
istoggle=[0,1,1];
was_set=istoggle * 0;
paramtype={'InputFile','String','String'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=0; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(0);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
callKhoros([w 'kgenstruct"  '],Inputs,narglist);
