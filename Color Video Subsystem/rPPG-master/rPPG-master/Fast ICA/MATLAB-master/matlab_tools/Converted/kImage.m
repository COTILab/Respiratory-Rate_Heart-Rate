%kImage 'Image Object Menuform'
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros Image.pane file
%
% Parameters: 
% Integer: imageXoffset 'Image X offset', default: 1: ' '
% Integer: imageYoffset 'Image Y offset', default: 1: ' '
% InputFile: imageImagefile ' Input Image ', required: 'input image'
% InputFile: colorColorfile 'Input Colormap', required: 'input file'
% InputFile: imageClipfile 'Input Clip Mask', required: 'clip mask file'
% OutputFile: imageSaveimage ' Output File ', required: 'output file'
% MultiChoice: colorNormMethod 'Normalization Method', default: 1: 'normalization method'
%    Choices are:
%   1: '0 <= values <= Max Colors'
%   2: '-1*(std.dev) <= values <= 1*(std.dev)'
%   3: '-2*(std.dev) <= values <= 2*(std.dev)'
%   4: '-3*(std.dev) <= values <= 3*(std.dev)'
%   5: 'Best Guess'
%   6: 'NO Normalization'
% String: colorRedFunction ' RED ', default: ' ': 'function defining red'
% String: colorGreenFunction 'GREEN', default: ' ': 'function defining green'
% String: colorBlueFunction 'BLUE ', default: ' ': 'function defining blue'
%
% Example: imageSaveimage = kImage({imageImagefile, colorColorfile, imageClipfile}, {'imageXoffset',1;'imageYoffset',1;'imageImagefile','';'colorColorfile','';'imageClipfile','';'imageSaveimage','';'colorNormMethod',1;'colorRedFunction',' ';'colorGreenFunction',' ';'colorBlueFunction',' '})
%
% Khoros helpfile follows below:
% .begin tagged
% 
% .item "The Image Visual Object"
% The image visual object provides a mechanism with which to easily display
% an image.  
% 
% .item "Image X offset"
% The image x offset specifies the horizontal offset within the image of the 
% image display window.  Together, the x offset and y offset specify the upper 
% left corner portion of the image that appears in the display window.  For
% small images which fit entirely within the image display window, this will
% always be (0,0);  however, for large images that must use a pan icon because
% the image will not fit entirely within the image window, the x offset may be
% any value from 0 to (width of image - image display window width).
% 
% .item "Image Y offset"
% The image y offset specifies the vertical offset within the image of the 
% image display window.  Together, the x offset and y offset specify the upper 
% left corner portion of the image that appears in the display window.  For
% small images which fit entirely within the image display window, this will
% always be (0,0);  however, for large images that must use a pan icon because
% the image will not fit entirely within the image window, the y offset may be
% any value from 0 to (height of image - image display window height).
% 
% .item "Input Image"
% Use this selection to specify the file containing the image to be displayed.
% 
% .item "Input Colormap"
% A file containing a color map to be used with the image specified by "Input
% Image" may be specified using this input file selection.  If the file specified
% by "Input Image" has a colormap associated with it, the file given for this
% selection will over-ride it.
% 
% .item "Output File"
% Use this output file selection to specify an output file to which the 
% currently displayed image will be written.
% 
% .item "Complex Data Conversion Type:"
% 
% .item "Type of Normalization"
% Before images are displayed by the image object, normalization must be done
% in order to ensure that the pixel values of the image fall within a visible
% range.  Normalization can be one of two types: local or global.  
% With local normalization, the normalization procedure is performed locally 
% using the maximum and minimum values of each of the red, green, and blue map
% columns.  For example, if the minimum and maximum
% values in the red column are 0 to 1, and the minimum and maximum values in the
% green column are 100 to 200, the red column will be normalized such that the
% value 0 stays 0, but the 1 value becomes 255, while the green column will be
% normalized such that the 100 value becomes 0, and the 200 value becomes 255.
% For global normalization, the normalization procedure is
% performed globally over all of the three columns displayed as red, green, and
% blue.  Thus, with global normalization, if the minimum and maximum values over
% all the red, green, and blue columns are 1 to 200, all three map columns will
% be normalized such that 1 becomes 0 and 200 becomes 255.
% 
% .item "Normalization Method"
% The normalization method allows different emphasis on how the data is displayed.
% The default, "Best Guess", tries to choose the correct normalization by looking 
% at the data to be displayed.  If the data is floating point or double and 
% between 0 and 1 (inclusive), the normalization chooses a minimum of 0 and a 
% maxium of 1 and scales accordingly.  Otherwise, if all the data is between 0 
% and 255 (inclusive), the normalization chooses a minimum of 0 and a maximum of 
% 255.  Note that global normalization will always be used in these cases.  If 
% neither of these conditions is met, then normalization is done as if the
% normalization method "0 <= values <= Max Colors" had been chosen.
% 
% The "0 <= values <= Max Colors" normalization method normalizes values to 
% within displayable intensity bounds (0 to 65535). 
% 
% Alternatively, images can have contrast increased or reduced using on of the
% standard deviation normalizations.  "-1*(std.dev) <= values <= 1*(std.dev)"
% will normalize values to within 1 standard deviation, "-2*(std.dev) <= values 
% <= 2*(std.dev)" will normalize values to within 2 standard deviations, and
% "-3*(std.dev) <= values <= 3*(std.dev)" will normalize values to within 3
% standard deviations.
% 
% Finally, choosing "No Normalization" causes normalization to be turned off
% altogether.  Note that this option assumes the data is already scaled between 
% 0 and 65535; thus, images of bit and byte data types as well as images with
% relatively small values will appear black.
% 
% .item "Change Red Map Col"
% An image with a simple colormap has three map columns associated with it, where
% the pixels in the image are used to index into the map columns; the first map
% column defines the red values, the second map column defines the green values,
% and the third map column defines the blue values.  In this way, the color for
% each pixel in the image is defined.   Some images, however, have more than
% three map columns; for example, output images produced by clustering algorithms
% may have many map columns, none of which is necessarily associated only with
% red, green, or blue values.  When multiple map columns are present, it may be
% useful to view any of the map columns as red, green, or blue.
% Thus, this button can be used to specify the index of the map column
% that is to be used to specify the red values for each of the pixels in the
% image.  Valid values are from "0" to \fIN-1\fP, where \fIN\fP is the number
% of map columns contained with the image.
% By default, the index of the map column specifying the red values is set to 0, 
% indicating the first map column; thus, it produces the results that you would
% normally expect for an RGB image where only three map columns were present.
% Note that setting the Red Map Column to the integer representing the desired
% map column is the same as entering the variable "Mx" as "Red Function", 
% where "x" is the index of the desired map column.  For example, using
% "Change Red Map Col" to change the red map column to map column 5 is the same 
% as setting "Red Function" to "M5".
% 
% .item "Change Green Map Col"
% This button is used to specify the index of the map column
% that is to be used to specify the green values for each of the pixels in the
% image.  See "Change Red Map Col" for details.
% 
% .item "Change Blue Map Col"
% This button is used to specify the index of the map column
% that is to be used to specify the blue values for each of the pixels in the
% image.  See "Change Red Map Col" for details.
% 
% .item "Red Function"
% With images having colormaps made up of more than three columns, such as those
% produced by clustering algorithms, it is often informative to be able to apply
% a function to the values in those map columns in order to define the values that
% will be displayed as each of the red, green, and blue columns.  For example, in
% an image having 6 map columns, you might define the red intensity of pixel 10 as
% (map column 2)[10]+ (map column 3)[10]/ (map column 4) [10].  In this case, the
% "Red Function" may be set to the string defining the function
% to be applied in order to produce the values that will be used as red.
% Functions must have "only" variable \fIM\fP, where \fIM\fP stands for "map
% column"; following each "M" must be a number \fIstarting at zero\fP and
% ranging to "N-1", where \fIN\fP is the number of map columns available in
% the image.  For example, a valid function for red might be:
% (M2 - M3)/(M2 + M3)
% or
% (M0 + M1 + M2)/(M3 - M4)
% Equation evaluation follows the standard rules of precedence; evaluation
% proceeds from left to right, and use of parentheses is fully supported.
% In a more simple use, the "Red Function" may also be the variable
% representing the map column which is to be used to specify the red values of
% the pixels in the image.  For example, if you wanted the fourth map column to
% define the red values of the pixels in the image, (remember that map column
% numbering begins at 0), you could set "Red Function" to:
% M3
% You can also set the "Red Function" to a constant, if desired.  For
% example, if you wanted the red values of all the pixels in the image to be 200,
% you could set "Red Function" to:
% 200
% By default, the "Red Function" is set to "M0", or the first map column;  
% thus, it produces the results that you would normally expect
% for an image with a colormap where no function was being applied.
% 
% .item "Green Function"
% Use this selection to enter a function that will determine the green values
% of the colormap; see "Red Function" for details.
% 
% .item "Blue Function"
% Use this selection to enter a function that will determine the green values
% of the colormap; see "Blue Function" for details.
% 
% .end tagged


function varargout = kImage(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kImage(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'imageXoffset', 1;'imageYoffset', 1;'imageImagefile', '__input';'colorColorfile', '__input';'imageClipfile', '__input';'imageSaveimage', '__output';'colorNormMethod', 1;'colorRedFunction', ' ';'colorGreenFunction', ' ';'colorBlueFunction', ' '};
maxval={10000,10000,0,0,0,0,0,0,0,0};
minval={-1,-1,0,0,0,0,0,0,0,0};
istoggle=[0,0,0,0,0,0,0,0,0,0];
was_set=istoggle * 0;
paramtype={'Integer','Integer','InputFile','InputFile','InputFile','OutputFile','MultiChoice','String','String','String'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=1; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'Image" '],Inputs,narglist);
