%kkgendepend 'Update Makefile for dependencies on *.h files.'
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros kgendepend.pane file
%
% Parameters: 
%
% Example: kkgendepend( {})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% kgendepend - Update Makefile for dependencies on *.h files.
%
%  DESCRIPTION
% "Kgendepend" reads each sourcefile typically a '*.c', '*.h', '*.l', '*.y'
% in sequence and parses it like a C-preprocessor, processing all #include,
% #define, #undef, #ifdef, #ifndef, #endif, #if and #else directives so that 
% it can correctly tell which #include, directives would be used in a 
% compilation.  Any #include directives can reference files having other
% #include directives, and parsing will occur in these files as well.
% 
% Every file that a sourcefile includes, directly or indirectly, is what
% "kgendepend" calls a "dependency".  These dependencies are then
% written to a Makefile in such a way that "make" will know which object 
% files must be recompiled when a dependency has changed.
% 
% "Kgendepend" places its output in the file named "Makefile".
% An alternate makefile may be specified with the [-f] option.
% It first searches the makefile for the line
%     # DO NOT DELETE THIS LINE -- make depend depends on it.
% or one provided with the [-s] option, as a delimiter for the dependency output.
% If it finds it, it will delete everything following this to the end of the 
% Makefile and put the output after this line.  If it doesn't find it, the program
% will append the string to the end of the makefile and place the output following
% that.  For each sourcefile appearing on the command line, "kgendepend" puts 
% lines in the makefile of the form
%      sourcefile.o: dfile ...
% Where "sourcefile.o" is the name from the command line with its suffix replaced 
% with ".o", and "dfile" is a dependency discovered in a #include directive while 
% parsing a source file or one of the files it included.
% 
% The approach used in this program enables it to run efficiently; central to 
% this performance are two assumptions: that all files compiled by a single
% Makefile will be compiled with roughly the same [-I] and [-D] options;
% and that most files in a single directory will include largely the same files.
% 
% Given these assumptions, "kgendepend" expects to be called once for each 
% Makefile, with all source files that are maintained by the Makefile appearing 
% on the command line.  It parses each source and include file exactly once, 
% maintaining an internal symbol table for each.  Thus, the first file on the 
% command line will take an amount of time proportional to the amount of time 
% that a normal C preprocessor takes.  On subsequent files, if it encounters 
% an include file that it has already parsed, it will not parse it again.
% 
% For example, imagine you are compiling two files, "file1.c" and "file2.c";
% suppose they each include the header file "header.h", and the file "header.h"
% in turn includes the files "def1.h" and "def2.h".
% When you run the command
%     % kgendepend file1.c file2.c
% "kgendepend" will parse "file1.c" and consequently, "header.h", and then
% "def1.h" and "def2.h".  It then decides that the dependencies for this file are
%     file1.o: header.h def1.h def2.h
% But when the program parses "file2.c" and discovers that it, too, includes
% "header.h".  Therefore, it does not parse the file, but simply adds "header.h",
% "def1.h" and "def2.h" to the list of dependencies for "file2.o".
% "kgendepend" will ignore any option that it does not understand so that 
% you may use the same arguments that you would for cc(1).
% 
%  "define"
% -Dname=def or \-Dname
% This places a definition for "name" in kmakedepend's symbol table.  
% Without "=def", the symbol becomes defined as "1".
% 
%  "include directory"
% -Iincludedir
% This option tells "kgendepend" to prepend "includedir\fP to its list of 
% directories to search when it encounters a #include directive.  By default,
% "kgendepend" only searches /usr/include.
% 
%  "Filename"
% -fmakefile
% This allows you to specify an alternate makefile in which "kmakedepend"
% can place its output.
% 
%  "Object file suffix"
% -oobjsuffix
% Some systems may have object files whose suffix is something other
% than ".o".  This option allows you to specify another suffix, such as
% ".b" with -o.b, or ":obj" with -o:obj, and so forth.
% 
%  "Starting string delimiter"
% -sstring
% This option permits you to specify a different string form "kgendepend"
% to look for in the Makefile.
% 
%  "Line width"
% -wwidth
% Normally, "kgendepend" will ensure that every output line that it writes 
% will be no wider than 78 characters for the sake of readability.  This option 
% enables you to change this width.
% 
%  "silencing"
% "-\ \- options \-\ \-"
% If "kgendepend" encounters a double hyphen (-\ \-) in the argument list,
% then any unrecognized argument following it will be silently ignored; a second 
% double hyphen terminates this special treatment.  In this way, "kgendepend"
% can be made to safely ignore esoteric compiler arguments that might
% normally be found in a CFLAGS make macro. (see the example below).
% All options that "kgendepend" recognizes and appear between the pair of 
% double hyphens are processed normally.
%
%  
%
%  EXAMPLES
% Normally, "kgendepend" will be used in a Makefile target so that typing 
% "make depend" will bring the dependencies up to date for the Makefile.
% For example,
% 
%     SRCS = file1.c file2.c ...
%     CFLAGS = -O -DHACK -I../foobar -xyz
%     depend:
%             kgendepend -- $(CFLAGS) -- $(SRCS)
% 
%
%  "SEE ALSO"
% cc(1), make(1), kgenmake(1), kgenimake(1), kimake(1)
%
%  RESTRICTIONS 
% If you do not have the source for cpp, the Berkeley C preprocessor,
% then "kgendepend" will be compiled in such a way that all #if
% directives will evaluate to "true" regardless of their actual value.
% This may cause the wrong #include directives to be evaluated. "kgendepend"
% should simply have its own parser written for #if expressions.
% 
% Imagine you are parsing two files, say, "file1.c" and "file2.c", each 
% including the file "def.h".  The list of files that "def.h" includes might 
% truly be different when "def.h" is included by "file1.c" than when it is 
% included by "file2.c".  But once "kgendepend" arrives at a list of 
% dependencies for a file, it is cast in stone.
%
%  REFERENCES 
% Original document on "makedepend", written by: Todd Brunhoff, 
% Tektronix, Inc. and MIT Project Athena
%
%  COPYRIGHT
% Copyright (C) 1993 - 1997, Khoral Research, Inc. ("KRI")  All rights reserved.
% 


function varargout = kkgendepend(varargin)
Inputs={};
if nargin ==0
  arglist={'',''};
elseif nargin ==1
  arglist=varargin{1};
else error('Usage: [out1,..] = kkgendepend(arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={};
maxval={};
minval={};
istoggle=[];
was_set=istoggle * 0;
paramtype={};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=0; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(0);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
callKhoros([w 'kgendepend"  '],Inputs,narglist);
