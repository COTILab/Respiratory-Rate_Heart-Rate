%kcbpnn_classify 'Classify an object using the Back-Propagation Neural Network algorithm '
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros cbpnn_classify.pane file
%
% Parameters: 
% InputFile: iimage 'Input Image', required: 'input image file'
% InputFile: inet 'Input Network', required: 'input the trained network file'
% OutputFile: oclass 'Output Classified', required: 'output classified image'
% OutputFile: oactiv 'Output Activations', optional: 'output activations file'
% OutputFile: oinfo 'Output Information', optional: 'output information about classification file'
% Toggle: uselargest 'Choose largest value as activated', default: 0: 'if set will use largest value as activated'
%
% Example: [oclass, oactiv, oinfo] = kcbpnn_classify({iimage, inet}, {'iimage','';'inet','';'oclass','';'oactiv','';'oinfo','';'uselargest',0})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% cbpnn_classify - Classify an object using the Back-Propagation Neural Network algorithm
%
%  DESCRIPTION
% This routine use a trained Back-Propagation Neural Network for classification of images. 
% Classification in the BPNN model is similar to training: the whole data is passed through the network, calculating an output. The trained step should had modified the weights so they should reproduce correct outputs when presented with inputs close to the presented samples for training. The activation values of the output determine the class for that particular data vector.
% The input image is passed with the [-iimage] parameter, and the trained network is passed with the [-inet] parameter. The trained network \fBmust" be the output of a "cbpnn_train\fP program. The input image can have any dimensions, but its element size must have the same size as the output layer of the trained network.
% The algorithm can evaluate the activation values in two ways: in the thresholded activation mode, the activation values are compared with a threshold (passed with the [-tactiv] parameter), and if one and only one of the activation values is larger than the threshold, its index will determine the class for that point. If no values are larger than the threshold, the point will be rejected.
% In the largest value mode, the largest of the activation values will determine the class regardless of its value. All points will be classified (no rejection).
% Optionally the output activations for each point will be output to a file, specified with the [-oactiv] parameter. Information about classification can also be output in ASCII if a file name is passed with the [-oinfo] parameter.
%
%  
%
%  EXAMPLES
% All examples for the Classify toolbox are listed on the Classify Toolbox Manual. For an example of this program, please see the example workspaces Classify:workspaces:BPNN-Image and Classify:workspaces:BPNN-Classify.
%
%  "SEE ALSO"
% cbpnn_signature, cbpnn_train, csigappend
%
%  RESTRICTIONS 
% Expects the input network to be a network properly trained with cbpnn_train.
%
%  REFERENCES 
% All references for the Classify toolbox are listed on the Classify Toolbox Manual.
%
%  COPYRIGHT
% Copyright (C) 1997 Rafael Santos. Khoros (C) Khoral Research, Inc.
% 


function varargout = kcbpnn_classify(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kcbpnn_classify(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'iimage', '__input';'inet', '__input';'oclass', '__output';'oactiv', '__output';'oinfo', '__output';'uselargest', 0};
maxval={0,0,0,1,1,0};
minval={0,0,0,1,1,0};
istoggle=[0,0,0,1,1,1];
was_set=istoggle * 0;
paramtype={'InputFile','InputFile','OutputFile','OutputFile','OutputFile','Toggle'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=1; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'cbpnn_classify"  '],Inputs,narglist);
