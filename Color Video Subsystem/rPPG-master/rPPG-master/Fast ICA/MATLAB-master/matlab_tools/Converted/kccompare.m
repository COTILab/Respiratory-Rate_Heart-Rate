%kccompare 'Compare two classification results and create confusion matrix'
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros ccompare.pane file
%
% Parameters: 
% InputFile: iclass 'Input Classified Image', required: 'input classified image'
% InputFile: itruth 'Input Truth Image', required: 'input truth (correctly classified) image'
% InputFile: icsf 'Class Specification File', required: 'input class specification file'
% MultiChoice: omode 'Output Mode', default: 1: 'output mode toggle'
%    Choices are:
%   1: 'Text'
%   2: 'LaTeX'
%   3: 'HTML'
%   4: 'CSV'
% OutputFile: oreport 'Output Report', optional: 'output report file'
%
% Example: oreport = kccompare({iclass, itruth, icsf}, {'iclass','';'itruth','';'icsf','';'omode',1;'oreport',''})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% ccompare - Compare two classification results and create confusion matrix
%
%  DESCRIPTION
% Compare a classification result (passed with the [-iclass] parameter) with a "ground truth" image (passed with the [-itruth] parameter) and generate a confusion matrix with omission, comission and correct classification. It also requires a Class Specification File to be passed with the [-icsf] parameter (the CSF file will be used to get the classes' names for the report). The format for the Class Specification File is listed in the "cclassreport" kman page.
% The main purpose of this program is to evaluate the classification results by comparing it with an already classified image (classified in the sense of being processed either by another classification program or visually interpreted by the user).
% It does not sound smart - if we have a classification result that can be trusted enough to be called "ground truth", why bother with another classification process ? The answer is that the comparison can be done with small representative regions of the images and if the results are good, the same classifier and parameters can be used for larger regions of the image. The comparison results can also show where there is too many misclassified pixels, hinting that some changes on the choice of classes, regions for signatures or classification method can improve the results.
% The ccompare program uses four data structures to show its results: a confusion matrix, an omission vector, a commission vector and the correct classification percentage, described below:
% The confusion matrix is calculated by how many pixels in the correct class X (from the ground truth image) were classified as classes 0 (rejected), 1, 2...N. The result is a matrix which diagonal shows where the classification result and the ground truth agreed. The final column of this matrix will be a total column, with each line corresponding to a class and showing the total pixels in the ground truth for that class. The final line of the matrix will also be a total line, with each column corresponding to a class and showing the total pixels classified as that class.
% The omission vector is calculated by analyzing for each class its corresponding line on the confusion matrix, and adding all values that are outside the diagonal of the confusion matrix, the comparing it with the total for that line. It means the percentage of pixels of class X that were not assigned to its correct class. 
% The commission vector is calculated by analyzing for each class its corresponding column on the confusion matrix, and adding all values that are outside the diagonal of the confusion matrix, the comparing it with the total for that line (the total number of pixels for the ground truth). It means the percentage of pixels of class X that were assigned to other classes than X. Note that the commission error and the omission error represent distinct concepts and their results are not directly related.
% The correct classification statistics are calculated as 100-the values of the omission vector.
% The overall accuracy is calculated by summing all values on the diagonal of the confusion matrix (corresponding to the number of correctly classified pixels, where the classified result and the ground truth agreed) and extracting the percentage compared with the total of pixels in the image.
% Result can be presented in different formats according to the [-omode] output mode parameter:
% * 1: Text ([-omode 1]): an ASCII text table will be created, with the cells in the matrix and vectors evenly spaced.
% * 2: LaTeX table ([-omode 2]): a LaTeX table, complete with caption and label. It can be included in any LaTeX file with the \\input command or read as a block of text using a text editor. The caption for the table will contain the file name of the classification result used for the generation of the report, and should be changed for reports - a reminder of this will appear when you run latex. For references about LaTeX, please refer to the Classify Toolbox Manual.
% * 3: HTML Table ([-omode 3]): will create a table formatted in HTML, including caption, ready for inclusion in HTML documents. The caption should be changed by the user, originally the file name will be used as caption.
% * 4: CSV comma-delimited text ([-omode 4]): create a comma-delimited file (where the fields are separated by commas) which can be read/imported by Excel and other spreadsheet applications. One caveat: if the class names in the Class Specification File has commas on it, the application reading the CSV report will get confused, some manual editing will be necessary.
%
%  
%
%  EXAMPLES
% All examples for the toolbox Classify are on the file $CLASSIFY/Readme.html. For an example of this program, please see the example workspace Classify:workspaces:KNN.
%
%  "SEE ALSO"
% cclassreport, Class Specification File format, described in the Classify Toolbox Manual.
%
%  RESTRICTIONS 
% The input ground truth must be an unmapped image, with the class indexes corresponding to the class indexes in the classified image. It means that a RGB image \fBcannot" be used as a ground truth without some pre-processing (see below). 
% One way to create a ground truth image is to use a graphics editor or any other package to "paint" the image to be classified with the same RGB colors that are specified in the Class Specification File, then unmapping it with the "cunmapdata" kroutine .
%
%  REFERENCES 
% All references for the toolbox Classify are on the file $CLASSIFY/Readme.html
%
%  COPYRIGHT
% Copyright (C) 1997 Rafael Santos. Khoros (C) Khoral Research, Inc.
% 


function varargout = kccompare(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kccompare(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'iclass', '__input';'itruth', '__input';'icsf', '__input';'omode', 1;'oreport', '__output'};
maxval={0,0,0,0,1};
minval={0,0,0,0,1};
istoggle=[0,0,0,0,1];
was_set=istoggle * 0;
paramtype={'InputFile','InputFile','InputFile','MultiChoice','OutputFile'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=0; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'ccompare"  '],Inputs,narglist);
