%kcsigappend 'Append and labels signatures of variable sizes'
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros csigappend.pane file
%
% Parameters: 
% InputFile: ipre 'Input Pre-appended', optional: 'input pre-appended file'
% InputFile: i1 'Input 1', required: 'First Input data object'
% InputFile: i2 'Input 2', optional: 'Input data object 2'
% InputFile: i3 'Input 3', optional: 'Input data object 3'
% InputFile: i4 'Input 4', optional: 'Input data object 4'
% InputFile: i5 'Input 5', optional: 'Input data object 5'
% InputFile: i6 'Input 6', optional: 'Input data object 6'
% InputFile: i7 'Input 7', optional: 'Input data object 7'
% InputFile: i8 'Input 8', optional: 'Input data object 8'
% InputFile: i9 'Input 9', optional: 'Input data object 9'
% InputFile: i10 'Input 10', optional: 'Input data object 10'
% OutputFile: o 'Output', required: 'Resulting output data object'
%
% Example: o = kcsigappend({ipre, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10}, {'ipre','';'i1','';'i2','';'i3','';'i4','';'i5','';'i6','';'i7','';'i8','';'i9','';'i10','';'o',''})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% csigappend - Append and labels signatures of variable sizes
%
%  DESCRIPTION
% This routine is used to append and label signatures of variable size in a single block for classification. It should be used to concatenate signatures for the classifiers which signatures aren't of the same size - e.g. the K-Nearest Neighbors classifier signatures can be of different sizes.
% Its input are several individual-classes signature files ([-i1], [-i2] ... [-i10] parameters). Each signature will also be labelled by the operator so the classifier can later identify which data belongs to which class. Labels are determined by the order the data is appended (considering also if a pre-appended, pre-labeled object was passed with the parameter [-ipre]). Output will be in the file specified by the parameter [-o].
% If there are more than 10 signatures to be appended, this operator's result can be used as the input of another copy of this operator (using the parameter [-ipre]), and the labelling will be done based on the labels already used. In other words, to connect more than 10 signatures use a net of these operators together, but don't concatenate their results together.
% The main differences from this operator to kappend are:
% * The objects are appended in the width dimension only, no map or mask is expected
% * The objects are labelled prior to appending
%
%  
%
%  EXAMPLES
% All examples for the Classify toolbox are listed on the Classify Toolbox Manual. For an example of this routine, please see the Classify:workspaces:KNN and Classify:workspaces:KNN-Signatures example workspaces.
%
%  "SEE ALSO"
% kappend, cknn_signature, cknn_classify
%
%  RESTRICTIONS 
% Expects the input data files to be in the expected dimensions.
%
%  REFERENCES 
% All references for the Classify toolbox are listed on the Classify Toolbox Manual.
%
%  COPYRIGHT
% Copyright (C) 1997 Rafael Santos. Khoros (C) Khoral Research, Inc.
% 


function varargout = kcsigappend(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kcsigappend(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'ipre', '__input';'i1', '__input';'i2', '__input';'i3', '__input';'i4', '__input';'i5', '__input';'i6', '__input';'i7', '__input';'i8', '__input';'i9', '__input';'i10', '__input';'o', '__output'};
maxval={1,0,1,1,1,1,1,1,1,1,1,0};
minval={1,0,1,1,1,1,1,1,1,1,1,0};
istoggle=[1,0,1,1,1,1,1,1,1,1,1,0];
was_set=istoggle * 0;
paramtype={'InputFile','InputFile','InputFile','InputFile','InputFile','InputFile','InputFile','InputFile','InputFile','InputFile','InputFile','OutputFile'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=1; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'csigappend"  '],Inputs,narglist);
