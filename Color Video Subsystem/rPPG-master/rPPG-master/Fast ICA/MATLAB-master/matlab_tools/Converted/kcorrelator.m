%kcorrelator 'alligns second image to match the first '
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros correlator.pane file
%
% Parameters: 
% InputFile: i1 'Reference Image', optional: 'serves as reference for allignment'
% InputFile: i2 'Image to allign', optional: 'will be alligned to first image'
% InputFile: i3 'Alternate image to shift', optional: 'will be alligned to first image'
% Integer: r 'region around maximum', default: 1: 'pixel around max that are evaluated in fourierspace'
% Double: expon 'Exponent', default: 1: 'If this is given, the data is raised to the power specified here. This can be used to suppress background information over the forground. The exponent will only be used for the determination of the shifts, but the shifts will be computed on the raw images!'
% Integer: steps 'Iteration Steps', default: 3: 'number of times the maximum search is done'
% Toggle: ishifts 'Indep. Shifts', default: 0: 'Determine shifts independently. If not selected : only element 0 is used for shifts, but all are shifted'
% Toggle: iscale 'Independent Scaling', default: 0: 'Determine scale for each element seperately. If not : element 0 gives scaling'
% Toggle: s 'Do Intensity scaling', default: 0: 'scale the second image to the first by its mean'
% Toggle: noshifts 'No Shifts', default: 0: 'Do only intensity scaling and no shifts (planes is ignored)'
% Toggle: onlyoffset 'Apply only offset', default: 0: 'Apply only offset correction'
% Double: phases 'HF enhance', default: 0.5: '!= 0 -> evaluate mostly phases with phase cross corellation. Formula : F0*F1\' / (abs(F0)+Max*phases) / (abs(F1)+Max*phases)'
% Toggle: p 'adjust planes', default: 0: 'shift planes one after each other to allign'
% Integer: fixplane 'fixed reference', default: 0: 'If selected, the number defines the fixed reference plane (0 to Zmax). If > Zmax, the last plane will be used.'
% Double: gf 'LP-GaussFilter', default: 0.3: 'If > 0.0, a Gauss-filter is applied in frequency space during computation of the cross-correlation. The frequency is relative to the image border.'
% Double: gfz 'Z', default: 1e+20: 'This is the Z-component of the low-pass Gaussfilter (if given as non-zero). A very high value means no filtering along Z is performed.'
% Double: md 'MaxRelDXY', default: 0.5: 'If given (> 0.0) the cross-correlation will be weighted linearly decreasing to the relative border distance'
% Double: mdz 'MaxRelDZ', default: 0.5: 'If given (> 0.0) the cross-correlation will be weighted linearly decreasing to the relative border distance in Z direction'
% Double: sl 'ScreamLlimit', default: 10: 'If this limit in total distance is exceeded, the program will end with an error. Data is still written to disc.'
% Toggle: plane 'Only XY shifts', default: 0: 'restrict the shifting to planes'
% Toggle: withprevelem 'WithPrevElem', default: 0: 'If selected, the correlation will always be with the previous element'
% Toggle: zflipadd 'Flip, Correl, CenterSum', default: 0: 'If selected, the image to align will be mirrored with respect to Z. Then correlated and added to the reference and the result will be centered'
% OutputFile: o 'Output', required: 'Resulting output data object'
% OutputFile: v 'ASCII Vectors', optional: 'Shift vectors are printed into file'
%
% Example: [o, v] = kcorrelator({i1, i2, i3}, {'i1','';'i2','';'i3','';'r',1;'expon',1;'steps',3;'ishifts',0;'iscale',0;'s',0;'noshifts',0;'onlyoffset',0;'phases',0.5;'p',0;'fixplane',0;'gf',0.3;'gfz',1e+20;'md',0.5;'mdz',0.5;'sl',10;'plane',0;'withprevelem',0;'zflipadd',0;'o','';'v',''})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% correlator - alligns second image to match the first
%
%  DESCRIPTION
%
%  
%
%  EXAMPLES
%
%  "SEE ALSO"
%
%  RESTRICTIONS 
%
%  REFERENCES 
%
%  COPYRIGHT
% Copyright (C) 1996-2003, Rainer Heintzmann,  All rights reserved.
% 


function varargout = kcorrelator(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kcorrelator(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'i1', '__input';'i2', '__input';'i3', '__input';'r', 1;'expon', 1;'steps', 3;'ishifts', 0;'iscale', 0;'s', 0;'noshifts', 0;'onlyoffset', 0;'phases', 0.5;'p', 0;'fixplane', 0;'gf', 0.3;'gfz', 1e+20;'md', 0.5;'mdz', 0.5;'sl', 10;'plane', 0;'withprevelem', 0;'zflipadd', 0;'o', '__output';'v', '__output'};
maxval={1,1,1,100,2,2,0,0,0,0,0,2,0,1,2,2,2,2,2,0,0,0,0,1};
minval={1,1,1,-100,2,2,0,0,0,0,0,2,0,1,2,2,2,2,2,0,0,0,0,1};
istoggle=[1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1];
was_set=istoggle * 0;
paramtype={'InputFile','InputFile','InputFile','Integer','Double','Integer','Toggle','Toggle','Toggle','Toggle','Toggle','Double','Toggle','Integer','Double','Double','Double','Double','Double','Toggle','Toggle','Toggle','OutputFile','OutputFile'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=1; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'correlator"  -k'],Inputs,narglist);
