%kcmaxmincluster 'Performs Max-Min Clustering '
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros cmaxmincluster.pane file
%
% Parameters: 
% InputFile: i1 'Input data object', required: 'input data object'
% Toggle: map 'Generate output map', default: 0: 'generate output map'
% Toggle: spectrum 'SPECTRUM compatable map segment', default: 0: 'SPECTRUM compatable map segment'
% OutputFile: o1 'Cluster number output object', required: 'Cluster number output object'
% OutputFile: o2 'Cluster center output object', optional: 'Cluster center output object'
% OutputFile: o3 'Cluster variance output object', optional: 'Cluster variance output object'
% OutputFile: o4 'Cluster membership count output', optional: 'Cluster membership count output'
% OutputFile: o5 'Max-Min statistics output (ASCII)', optional: 'Max-Min statistics output (ASCII)'
%
% Example: [o1, o2, o3, o4, o5] = kcmaxmincluster(i1, {'i1','';'map',0;'spectrum',0;'o1','';'o2','';'o3','';'o4','';'o5',''})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% cmaxmincluster - Performs Max-Min Clustering
%
%  DESCRIPTION
% This program performs Max-Min clusterng on the input data. The Max-Min algorithm works by scanning the data and creating new clusters whenever a data point seems to be well-separated from the already existing clusters. The advantage of this algorithm is that it determines automatically the number of clusters. Its details are as follows:
% The first cluster center is chosen to be the first data value. The value that is furthest away from the first cluster is chosen to be the second cluster center. 
% From this point on, the algorithm will scan all unassigned data points for the minimum distances from these points to the cluster centers, and get the maximum of these points as a new cluster center if its distance is larger than a threshold. The threshold is calculated using a weighted distance of the already determined cluster centers.
% Clustering is terminated when it is not possible to get another new cluster center under the conditions above. A final step rescans all the data and assign each value to the index of its closest cluster center.
% This algorithm has the advantage of determining automatically the number of clusters, but it is strongly dependent on the order the samples are presented as input, and it will work better with well-separated clusters. One way to control the cluster generation is specifying a threshold multiplication factor with the [-tfactor] parameter, values < 1 will yield larger thresholds, creating fewer clusters, and values > 1 will yield smaller thresholds, creating more clusters. Unfortunately this parameter can be determined only by trial and error. \fBWarning:" setting this parameter to high values (e.g. more than 3) can slow down the clustering (specially if the clusters on it are not well-separated) making it useless for practical applications.
% This program expects as input the data file to be clustered (passed by the parameter [-i1]) and the output clustered data (passed by the parameter [-o1]). As with other clustering algorithms in this toolbox and "kkmeans" in the datamanip toolbox, the output clustered object can have a map that is obtained by the center of the clusters (if the parameter [-map] is passed), and a Spectrum-compatable map if both parameters [-map] and [-spectrum] are passed, but a caveat is needed here: the statistics for the cluster centers and the Spectrum-compatable map are calculated after the clustering since the choices for cluster seeds in the main loop of the algorithm are not iteractively updated to represent the center of the cluster.
% Other outputs are similar to the used by "kkmeans", \fIcfuzzycmeans\fP and \fIckmeans2\fP: [-o2] will contain the cluster centers, [-o3] will contain the cluster variances, [-o4] will contain the cluster counts and [-o5] will contain information about the clustering (in ASCII). Please refer to the kman page for \fIkkmeans\fP for more details about these files.
% Mask data is considered, only points that are not masked are considered for the clustering.
%
%  
%
%  EXAMPLES
% All examples for the Classify toolbox are listed on the Classify Toolbox Manual. For an example for this program, please see the example workspace Classify:workspaces:MaxMinCluster.
%
%  "SEE ALSO"
% ckmeans2, kkmeans, cfuzzycmeans
%
%  RESTRICTIONS 
%
%  REFERENCES 
% All references for the Classify toolbox are listed on the Classify Toolbox Manual.
%
%  COPYRIGHT
% Copyright (C) 1997 Rafael Santos. Khoros (C) Khoral Research, Inc.
% 


function varargout = kcmaxmincluster(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kcmaxmincluster(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'i1', '__input';'map', 0;'spectrum', 0;'o1', '__output';'o2', '__output';'o3', '__output';'o4', '__output';'o5', '__output'};
maxval={0,0,0,0,1,1,1,1};
minval={0,0,0,0,1,1,1,1};
istoggle=[0,1,1,0,1,1,1,1];
was_set=istoggle * 0;
paramtype={'InputFile','Toggle','Toggle','OutputFile','OutputFile','OutputFile','OutputFile','OutputFile'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=1; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'cmaxmincluster"  '],Inputs,narglist);
