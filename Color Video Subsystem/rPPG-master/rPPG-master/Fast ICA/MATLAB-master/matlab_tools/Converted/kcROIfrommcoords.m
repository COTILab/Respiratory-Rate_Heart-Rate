%kcROIfrommcoords 'Extract ROIs from multiple labeled coords for samples evaluation '
% This MatLab function was automatically generated by a converter (KhorosToMatLab) from the Khoros cROIfrommcoords.pane file
%
% Parameters: 
% InputFile: i 'Input Image file', required: 'input image file to be masked'
% InputFile: icoords 'Input Multiple Coords File', required: 'input file with multiple, labeled coordinates'
% OutputFile: oimage 'Output Masked Image', optional: 'output the image masked with the ROIs'
% OutputFile: opseudo 'Output Pseudo Ground Truth', optional: 'output file with pseudo ground truth image'
%
% Example: [oimage, opseudo] = kcROIfrommcoords({i, icoords}, {'i','';'icoords','';'oimage','';'opseudo',''})
%
% Khoros helpfile follows below:
%
%  PROGRAM
% cROIfrommcoords - Extract ROIs from multiple labeled coords for samples evaluation
%
%  DESCRIPTION
% This program can be used to create an image with all regions that were used as samples unmasked and all the rest of the image masked as false ([-oimage] parameter). Optionally a pseudo ground-truth image ([-opseudo] parameter) can also be created, the points used as samples will have the index of the classes as values, and regions outside the ROIs will be masked as false.
% The main application of this program is to create a special version of the image to be classified (with only the samples or ROIs regions) and its respective pseudo ground truth. If this image is classified and compared with the pseudo ground truth, disparities on the samples will be visible. For example, suppose that you select regions for class A with pixels that actually belong to class B. When the image with both classes A and B samples's is classified, regions that were selected as class A will appear misclassified, making easier for the user to change the samples' region or assignment.
% This program expects as input an multiband image ([-i] parameter) and a file in the MCoords format (multiple coordinates format, [-icoords] parameter), an ASCII file which format is:
% * lines starting with # or / are considered as comments
% * lines with less than 9 characters on it are ignored
% * each line should have 5 coordinates: index of class, start column, start row, width, height, separated by one or more spaces.
% The MCoords format is seldom created manually by the user, the "cappendROIcoords" kroutine can append and label automatically the coordinates from several Coords files, its output should be used by \fIcROIfrommcoords\fP.
% This programs' user interface and functionality are simpler than "cROIfromcoords": all points inside the coordinates will be considered as ROIs, points outside the ROIs will be masked as nonvalid, the image will not be cropped (original size is maintained). 
% If the optional pseudo ground truth image is created, the program will report all cases of pixels assigned simultaneously to different classes - good to check if the samples are OK.
%
%  
%
%  EXAMPLES
% All examples for the Classify toolbox are listed on the Classify Toolbox Manual. For a specific example of this routine, please see the example workspace Classify:workspaces:MINDIST-EvalSamples.
%
%  "SEE ALSO"
% cROIfromcoords, cappendROIcoords.
%
%  RESTRICTIONS 
% The coordinates specified in the file must be inside the range of the image file, i.e. they must contain valid coordinates.
%
%  REFERENCES 
% All references for the Classify toolbox are listed on the Classify Toolbox Manual.
%
%  COPYRIGHT
% Copyright (C) 1997 Rafael Santos. Khoros (C) Khoral Research, Inc.
% 


function varargout = kcROIfrommcoords(varargin)
if nargin ==0
  Inputs={};arglist={'',''};
elseif nargin ==1
  Inputs=varargin{1};arglist={'',''};
elseif nargin ==2
  Inputs=varargin{1}; arglist=varargin{2};
else error('Usage: [out1,..] = kcROIfrommcoords(Inputs,arglist).');
end
if size(arglist,2)~=2
  error('arglist must be of form {''ParameterTag1'',value1;''ParameterTag2'',value2}')
 end
narglist={'i', '__input';'icoords', '__input';'oimage', '__output';'opseudo', '__output'};
maxval={0,0,1,1};
minval={0,0,1,1};
istoggle=[0,0,1,1];
was_set=istoggle * 0;
paramtype={'InputFile','InputFile','OutputFile','OutputFile'};
% identify the input arrays and assign them to the arguments as stated by the user
if ~iscell(Inputs)
Inputs = {Inputs};
end
NumReqOutputs=0; nextinput=1; nextoutput=1;
  for ii=1:size(arglist,1)
  wasmatched=0;
  for jj=1:size(narglist,1)
   if strcmp(arglist{ii,1},narglist{jj,1})  % a given argument was matched to the possible arguments
     wasmatched = 1;
     was_set(jj) = 1;
     if strcmp(narglist{jj,2}, '__input')
      if (nextinput > length(Inputs)) 
        error(['Input ' narglist{jj,1} ' has no corresponding input!']); 
      end
      narglist{jj,2} = 'OK_in';
      nextinput = nextinput + 1;
     elseif strcmp(narglist{jj,2}, '__output')
      if (nextoutput > nargout) 
        error(['Output nr. ' narglist{jj,1} ' is not present in the assignment list of outputs !']); 
      end
      if (isempty(arglist{ii,2}))
        narglist{jj,2} = 'OK_out';
      else
        narglist{jj,2} = arglist{ii,2};
      end

      nextoutput = nextoutput + 1;
      if (minval{jj} == 0)  
         NumReqOutputs = NumReqOutputs - 1;
      end
     elseif isstr(arglist{ii,2})
      narglist{jj,2} = arglist{ii,2};
     else
        if strcmp(paramtype{jj}, 'Integer') & (round(arglist{ii,2}) ~= arglist{ii,2})
            error(['Argument ' arglist{ii,1} ' is of integer type but non-integer number ' arglist{ii,2} ' was supplied']);
        end
        if (minval{jj} ~= 0 | maxval{jj} ~= 0)
          if (minval{jj} == 1 & maxval{jj} == 1 & arglist{ii,2} < 0)
            error(['Argument ' arglist{ii,1} ' must be bigger or equal to zero!']);
          elseif (minval{jj} == -1 & maxval{jj} == -1 & arglist{ii,2} > 0)
            error(['Argument ' arglist{ii,1} ' must be smaller or equal to zero!']);
          elseif (minval{jj} == 2 & maxval{jj} == 2 & arglist{ii,2} <= 0)
            error(['Argument ' arglist{ii,1} ' must be bigger than zero!']);
          elseif (minval{jj} == -2 & maxval{jj} == -2 & arglist{ii,2} >= 0)
            error(['Argument ' arglist{ii,1} ' must be smaller than zero!']);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} < minval{jj})
            error(['Argument ' arglist{ii,1} ' must be bigger than ' num2str(minval{jj})]);
          elseif (minval{jj} ~= maxval{jj} & arglist{ii,2} > maxval{jj})
            error(['Argument ' arglist{ii,1} ' must be smaller than ' num2str(maxval{jj})]);
          end
        end
     end
     if ~strcmp(narglist{jj,2},'OK_out') &  ~strcmp(narglist{jj,2},'OK_in') 
       narglist{jj,2} = arglist{ii,2};
     end
   end
   end
   if (wasmatched == 0 & ~strcmp(arglist{ii,1},''))
        error(['Argument ' arglist{ii,1} ' is not a valid argument for this function']);
   end
end
% match the remaining inputs/outputs to the unused arguments and test for missing required inputs
 for jj=1:size(narglist,1)
     if  strcmp(paramtype{jj}, 'Toggle')
        if (narglist{jj,2} ==0)
          narglist{jj,1} = ''; 
        end;
        narglist{jj,2} = ''; 
     end;
     if  ~strcmp(narglist{jj,2},'__input') && ~strcmp(narglist{jj,2},'__output') && istoggle(jj) && ~ was_set(jj)
          narglist{jj,1} = ''; 
          narglist{jj,2} = ''; 
     end;
     if strcmp(narglist{jj,2}, '__input')
      if (minval{jj} == 0)  % meaning this input is required
        if (nextinput > size(Inputs)) 
           error(['Required input ' narglist{jj,1} ' has no corresponding input in the list!']); 
        else
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        end
      else  % this is an optional input
        if (nextinput <= length(Inputs)) 
          narglist{jj,2} = 'OK_in';
          nextinput = nextinput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end;
     else 
     if strcmp(narglist{jj,2}, '__output')
      if (minval{jj} == 0) % this is a required output
        if (nextoutput > nargout & nargout > 1) 
           error(['Required output ' narglist{jj,1} ' is not stated in the assignment list!']); 
        else
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
          NumReqOutputs = NumReqOutputs-1;
        end
      else % this is an optional output
        if (nargout - nextoutput >= NumReqOutputs) 
          narglist{jj,2} = 'OK_out';
          nextoutput = nextoutput + 1;
        else 
          narglist{jj,1} = '';
          narglist{jj,2} = '';
        end;
      end
     end
  end
end
if nargout
   varargout = cell(1,nargout);
else
  varargout = cell(1,1);
end
global KhorosRoot
if exist('KhorosRoot') && ~isempty(KhorosRoot)
w=['"' KhorosRoot];
else
if ispc
  w='"C:\Program Files\dip\khorosBin\';
else
[s,w] = system('which cantata');
w=['"' w(1:end-8)];
end
end
[varargout{:}]=callKhoros([w 'cROIfrommcoords"  '],Inputs,narglist);
